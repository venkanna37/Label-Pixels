"""
ResUNet model proposed for road extraction
 - refer: https://arxiv.org/abs/1711.10684
"""

from keras.models import *
from keras.layers import Input, Conv2D, UpSampling2D, BatchNormalization, Activation, add, concatenate


def res_block(x, nb_filters, strides):
    res_path = BatchNormalization()(x)
    res_path = Activation(activation='relu')(res_path)
    res_path = Conv2D(filters=nb_filters[0], kernel_size=(3, 3), padding='same', strides=strides[0])(res_path)
    res_path = BatchNormalization()(res_path)
    res_path = Activation(activation='relu')(res_path)
    res_path = Conv2D(filters=nb_filters[1], kernel_size=(3, 3), padding='same', strides=strides[1])(res_path)
    shortcut = Conv2D(nb_filters[1], kernel_size=(1, 1), strides=strides[0])(x)
    shortcut = BatchNormalization()(shortcut)
    res_path = add([shortcut, res_path])
    return res_path


def encoder(x):
    to_decoder = []
    main_path = Conv2D(filters=64, kernel_size=(3, 3), padding='same', strides=(1, 1))(x)
    main_path = BatchNormalization()(main_path)
    main_path = Activation(activation='relu')(main_path)
    main_path = Conv2D(filters=64, kernel_size=(3, 3), padding='same', strides=(1, 1))(main_path)
    shortcut = Conv2D(filters=64, kernel_size=(1, 1), strides=(1, 1))(x)
    shortcut = BatchNormalization()(shortcut)
    main_path = add([shortcut, main_path])
    # first branching to decoder
    to_decoder.append(main_path)
    main_path = res_block(main_path, [128, 128], [(2, 2), (1, 1)])
    to_decoder.append(main_path)
    main_path = res_block(main_path, [256, 256], [(2, 2), (1, 1)])
    to_decoder.append(main_path)
    return to_decoder


def decoder(x, from_encoder):
    main_path = UpSampling2D(size=(2, 2))(x)
    main_path = concatenate([main_path, from_encoder[2]], axis=3)
    main_path = res_block(main_path, [256, 256], [(1, 1), (1, 1)])
    main_path = UpSampling2D(size=(2, 2))(main_path)
    main_path = concatenate([main_path, from_encoder[1]], axis=3)
    main_path = res_block(main_path, [128, 128], [(1, 1), (1, 1)])
    main_path = UpSampling2D(size=(2, 2))(main_path)
    main_path = concatenate([main_path, from_encoder[0]], axis=3)
    main_path = res_block(main_path, [64, 64], [(1, 1), (1, 1)])
    return main_path


def build_res_unet(input_shape, num_classes):
    # input_shape = tuple(args.input_shape)
    inputs = Input(shape=input_shape)
    to_decoder = encoder(inputs)
    path = res_block(to_decoder[2], [512, 512], [(2, 2), (1, 1)])
    path = decoder(path, from_encoder=to_decoder)
    if num_classes > 1:
        path = Conv2D(num_classes, kernel_size=(1, 1), activation='softmax')(path)
    elif num_classes == 1:
        path = Conv2D(filters=1, kernel_size=(1, 1), activation='sigmoid')(path)
    return Model(inputs, path)


def model_summary(input_shape, num_classes):
    model = build_res_unet(input_shape, num_classes)
    model.summary()
